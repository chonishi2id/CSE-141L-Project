1. Program 1 works as expected, which we verified through our testbench and simulation. 
The control flow also works as expected with the value of the program counter being updated correctly for both bnzl and bnzr instructions.
2. 
One major challenge we faced when implementing our design was deciding how to support branching instructions. We initially planned to use absolute jumps but realized that we actually have quite a lot of branching instructions in the program implementations and that relative jumping would be much more efficient. After deciding this, we were then presented with the challenge of how to store the offsets larger than 256 since they could not be stored in a register so we decided to use a look up table. The problem that followed this was realizing we can only have up to 16 elements in a LUT and we had many more branch instructions than that. So we ultimately decided on having two branch instructions, bnzr and bnzl, and only using the LUT for those offsets larger than 256, which is less than 16. Another challenge we faced was just the entire debugging process because we had to determine if the issue or bug was because of our architecture or the actual program implementation. One way we were able to make debugging more effective and narrow the problem down was first debugging the architecture, and if it we confirmed that each component is working as intended,  we then went through the program by hand with a specific test case which showed us that there were a lot of issues with the program implementations and we were able to debug with more clarity from there. 
3. Link to video:
Passcode: 
