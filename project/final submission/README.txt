1. Program 1 works as expected, which we verified through our testbench and simulation. For all test cases, the correct output values are written into data memory in the correct addresses. The control flow also works as expected with the value of the program counter being updated correctly for both bnzl and bnzr instructions.
2. Program 2 does not work as expected as the results of our testbench and simulation are incorrect for 7/30 test cases. This means that only 7 correct messages are written into datamem[94:123]. Our best guess as to why the output is not correct for all cases is because there is a mistake in calcuating the error correction and error detection which results in an incorrect message being written to data memory.
One major challenge we faced when implementing our design was deciding how to support branching instructions. We initially planned to use absolute addresses for jumps but realized that we actually have quite a lot of branching instructions in the program implementations and that relative jumping would be much more efficient to reduce issues with code rewrites and help us stay within the bounds of a 16-valued LUT. After deciding this, we were then presented with the challenge of how to store the offsets larger than 256 since they could not be stored in a register so we decided to use a look up table. The problem that followed this was realizing we can only have up to 16 elements in a LUT and we had many more branch instructions than that. So we ultimately decided on having two branch instructions, bnzr and bnzl, and only using the LUT for those offsets larger than 256, which is less than 16. Another challenge we faced was debugging effectively. There were so many moving values to track and deciding where to look for a bug was not as simple as setting a breakpoint to check out a function. We had to determine if the issue or bug was because of our architecture or the actual program implementation. One way we were able to make debugging more effective and narrow the problem down was first debugging the architecture, and if it we confirmed that each component is working as intended,  we then went through the program by hand with a specific test case which showed us that there were a lot of issues with the program implementations and we were able to debug with more clarity from there. 
For Program 3, we tried many cycles of rewriting the code, manually running examples, and resimulating the program. Our program ultimately counts each value incorrectly, with the current implementation counting 16 recognitions of the pattern for each bound in test case 01. The challenge with completing this program seems to be within implementing the correct sequence of steps in our instruction set as opposed to being an issue with our processor design, which we think is able to riun the program given the correct sequence of instructions.
3. Link to video:
Passcode: 
